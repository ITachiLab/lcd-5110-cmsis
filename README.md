# LCD from Nokia 5110 on Nucleo

## Introduction

This is a CMSIS based implementation of a simple LCD from Nokia 5110, running on a Nucleo F103RB board. This project has been created by me, for me, to learn basics of STM32 microcontrollers, and I know of no better way to learn such things than doing this on registers.

## Why not HAL?

HAL is in my opion bloated and vaguely documented. I don't like the way the code is organized after being generated by CubeMX. I simply can't understand what's going on and why. It's better to spent 8 hours on learning STM32 architecture, than on trying to figure out what HAL developers had in mind and what they doped.

I'm an extreme opponent of doing things without knowing what they really do (that's why I despise whole Arduino concept). If you feel comfortable with such abstraction, that's okay, but keep in mind, that you can do better.

## What's in the code

The main purpose of this program is to constantly write a screen buffer to the LCD (SPI), and receive the screen buffer from the PC (USART). Both operations are done with a help of a DMA, so no loops are used and everything is extremely fast.

- Setting up clocks for peripherals
- Setting up timer for delay
- Setting up ports
- Setting up SPI in a DMA transmission mode
- Setting up USART in a DMA reception mode

## How to use it

Connect your Nokia 5110 LCD as follows:
```
RST --- PB9
CE  --- PB6
DC  --- PB8
DIN --- PA7 (SPI1 MOSI)
CLK --- PA5 (SPI1 CLK)
VCC --- +3v3
BL  --- To VCC through 1k1 resistor
GND --- GND
```

Run the code, open up terminal like **minicom** and send anything that contains **504** bytes of data. One byte is 8 vertical pixels so (504 * 8) = (48 * 84) = 4032 pixels on screen. You can find example files in the root directory - `random.bin` and `zeros.bin`.

For example, sending a combination like: `0x00 0x01 0x02 0x03 0x04 0xFF 0xFF` will give this effect:

```
         X ->
   0 # 0 # 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
   0 0 # # 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
Y  0 0 0 0 # # # 0 0 0 0 0 0 0 0 0 0 0 0 0
   0 0 0 0 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
|  0 0 0 0 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
V  0 0 0 0 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
   0 0 0 0 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
   0 0 0 0 0 # # 0 0 0 0 0 0 0 0 0 0 0 0 0
   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

This is only a small part of the screen to demonstrate how the bits are mapped. Sending 0xFF 84 times will draw a black, 8 pixels high, horizontal line on top of the screen. Just play with this and you will see what's going on. "0" bits are displayed as white, and "1" bits as black by default, you can change that easily in the code.
